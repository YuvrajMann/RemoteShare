<!DOCTYPE html>
<html>
<head>
  <title>Remote Share - Shared Media</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    /* Media session styles */
    .media-container {
      max-width: 800px;
      margin: 2rem auto;
      padding: 1.5rem;
      border-radius: 12px;
      background: #fff;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    
    body.dark-mode .media-container {
      background: #2d2d2d;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    
    #mediaTitle {
      text-align: center;
      margin-bottom: 1.5rem;
      color: #1976d2;
      font-weight: 600;
    }
    
    body.dark-mode #mediaTitle {
      color: #90caf9;
    }
    
    #remoteMedia {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 1rem;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      font-size: 0.9rem;
      color: #757575;
      margin: 1rem 0;
    }
    
    body.dark-mode .status-indicator {
      color: #aaa;
    }
    
    .status-indicator .material-icons {
      margin-right: 8px;
      color: #4CAF50;
    }
    
    .status-indicator.connecting .material-icons {
      color: #FFC107;
    }
    
    .status-indicator.error .material-icons {
      color: #F44336;
    }
  </style>
</head>

<body>
  <div class="header">
    <div class="container" style="display: flex; align-items: center; justify-content: space-between;">
      <div class="logo" style="display: flex; align-items: center;">
        <i class="material-icons">folder_shared</i>
        Remote Share
      </div>
      <div>
        <button id="theme-toggle" class="theme-toggle-btn">
          <i id="theme-icon" class="material-icons">dark_mode</i>
        </button>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="media-container">
      <h5 id="mediaTitle">Joining shared media session...</h5>
      
      <div class="status-indicator connecting">
        <i class="material-icons">sync</i>
        <span>Connecting to host...</span>
      </div>
      
      <div id="mediaWrapper">
        <!-- Remote media will be added here -->
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    let socket;
    
    function attemptToPlay(mediaElement) {
      const s = document.querySelector('.status-indicator');
      if (mediaElement.currentSrc) {
        s.classList.remove('connecting', 'error');
        s.classList.add('warning');
        s.querySelector('i').textContent = 'touch_app';
        s.querySelector('span').textContent = 'Click play to start listening';
      }
      const p = mediaElement.play();
      if (p && typeof p.then === 'function') {
        p.then(() => {
          s.classList.remove('warning'); 
          s.classList.add('active');
          s.querySelector('i').textContent = 'hearing';
          s.querySelector('span').textContent = 'Connected to stream';
        }).catch(() => {/* autoplay blocked */});
      }
    }

    function initSession(sessionId, fileId) {
      const s = document.querySelector('.status-indicator');
      const mediaWrapper = document.getElementById('mediaWrapper');
      
      // Determine media type from URL
      const mediaType = new URLSearchParams(window.location.search).get('type') || 'audio';
      
      // Create media element
      const mediaElement = document.createElement(mediaType);
      mediaElement.id = 'remoteMedia';
      mediaElement.controls = true;
      mediaWrapper.innerHTML = '';
      mediaWrapper.appendChild(mediaElement);
      
      let controlLock = false;
      let lastSyncTime = 0;
      
      // Load the media directly via HTTP
      mediaElement.src = `/media/stream/${fileId}`;
      mediaElement.preload = 'auto';
      s.classList.add('connecting');
      s.querySelector('i').textContent = 'sync';
      s.querySelector('span').textContent = 'Buffering media...';

      const markReady = () => {
        document.getElementById('mediaTitle').textContent = mediaType === 'video' ? 'Shared Video' : 'Shared Audio';
        attemptToPlay(mediaElement);
      };
      mediaElement.addEventListener('loadedmetadata', markReady, { once: true });
      mediaElement.addEventListener('canplay', markReady, { once: true });

      // Connect to Socket.IO
      socket = io();
      socket.on('connect', () => {
        socket.emit('join-session', { sessionId });
        // Request initial sync
        socket.emit('request-sync', { sessionId });
      });

      // Handle media control events from host/others
      const applySync = (syncData) => {
    if (syncData.senderId === socket.id) return;
    
    controlLock = true;
    const syncThreshold = 0.4; // Tighter sync threshold
    
    try {
        // Enhanced latency calculation
        const networkLatency = syncData.timestamp ? (Date.now() - syncData.timestamp) / 1000 : 0;
        const serverLatency = syncData.serverTime ? (Date.now() - syncData.serverTime) / 1000 : 0;
        const avgLatency = Math.min((networkLatency + serverLatency) / 2, 2.0); // Cap at 2 seconds
        
        console.log(`Viewer sync: ${syncData.action} at ${syncData.position.toFixed(2)}s, latency: ${(avgLatency * 1000).toFixed(0)}ms`);
        
        let targetPosition = syncData.position;
        
        // Add latency compensation for play/sync actions only
        if (syncData.action === 'play' || syncData.action === 'sync') {
            targetPosition += avgLatency;
        }
        
        if (syncData.action === 'play') {
            // Explicit play - sync time and play
            const drift = Math.abs(mediaElement.currentTime - targetPosition);
            if (drift > syncThreshold) {
                console.log(`Viewer correcting play drift: ${drift.toFixed(2)}s`);
                mediaElement.currentTime = targetPosition;
            }
            
            if (mediaElement.paused) {
                attemptToPlay(mediaElement);
            }
            
        } else if (syncData.action === 'pause') {
            // Explicit pause - sync time and pause
            mediaElement.currentTime = syncData.position;
            if (!mediaElement.paused) {
                mediaElement.pause();
            }
            
        } else if (syncData.action === 'seek') {
            // Seek - just update position
            mediaElement.currentTime = targetPosition;
            
        } else if (syncData.action === 'sync') {
            // Periodic sync - only correct significant drift, don't change play state
            const drift = Math.abs(mediaElement.currentTime - targetPosition);
            if (drift > syncThreshold) {
                console.log(`Viewer correcting sync drift: ${drift.toFixed(2)}s`);
                mediaElement.currentTime = targetPosition;
            }
            // Don't change play/pause state for sync events
        }
        
    } catch (e) {
        console.warn('Viewer sync error:', e);
    } finally {
        setTimeout(() => { controlLock = false; }, 150);
    }
};

      socket.on('media-control', applySync);

      // Periodically request sync from host
      setInterval(() => {
        socket.emit('request-sync', { sessionId });
      }, 5000);

      // Local media controls -> send to others
      mediaElement.onplay = () => {
        if (controlLock) return;
        const statusIndicator = document.querySelector('.status-indicator');
        statusIndicator.classList.remove('warning'); 
        statusIndicator.classList.add('active');
        statusIndicator.querySelector('i').textContent = 'hearing';
        statusIndicator.querySelector('span').textContent = 'Connected to stream';
        
        socket.emit('media-control', { 
          action: 'play', 
          position: mediaElement.currentTime, 
          sessionId, 
          senderId: socket.id 
        });
      };
      
      mediaElement.onpause = () => {
        if (controlLock) return;
        socket.emit('media-control', { 
          action: 'pause', 
          position: mediaElement.currentTime, 
          sessionId, 
          senderId: socket.id 
        });
      };
      
      mediaElement.onseeking = () => {
        if (controlLock) return;
        socket.emit('media-control', { 
          action: 'seek', 
          position: mediaElement.currentTime, 
          sessionId, 
          senderId: socket.id 
        });
      };
    }

    document.addEventListener('DOMContentLoaded', function() {
      const sessionId = window.location.pathname.split('/').pop();
      const fileId = new URLSearchParams(window.location.search).get('fileId');
      
      if (sessionId && fileId) {
        initSession(sessionId, fileId);
      } else {
        const s = document.querySelector('.status-indicator');
        s.classList.add('error');
        s.querySelector('i').textContent = 'error';
        s.querySelector('span').textContent = 'Invalid session link';
      }
      
      // Theme toggle logic
      const themeToggle = document.getElementById('theme-toggle');
      const themeIcon = document.getElementById('theme-icon');
      
      if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark-mode');
        themeIcon.textContent = 'light_mode';
      }
      
      themeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        themeIcon.textContent = isDark ? 'light_mode' : 'dark_mode';
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
      });
    });
  </script>
</body>
</html>